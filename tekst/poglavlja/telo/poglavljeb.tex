\section{Паралелно решење проналаска суме у бинарном стаблу}

\subsection{Опис паралелног решења}
Дефинишимо \textit{дете-стабло} као стабло чији је корен дете датог чвора.

Секвенцијално решење не користи чињеницу да се "лево" и "десно" дете-стабло могу независно обрађивати.
Тачније, родитељ-чвор измрешћује (енг. \textit{spawn}) две независне нити извршавања где прва обрађује лево, а друга десно дете-стабло.
Спајање (енг. \textit{join}) нити такође врши родитељ, преузимајући резултате обрада.
Особина да се обрађује само лево дете-стабло уколико се у њему пронађе решење се овиме губи.

Међутим, у имплементационом смислу, оптимално решење није да се свако дете-стабло обрађује независно тј.
у посебном OpenMP задатку, јер тиме се оптерећује извршно окружење OpenMP-а тј. доста процесорског времена
се потроши на прекључивање контекста задатака уместо на ефективном раду и извршавању задатака.

Предлаже се паралелно решење које независно обрађује стабла чији су корени на нивоу $l$, таквом да:
\begin{equation}
\begin{split}
\label{eq:myequation}
    l &= max_i 2^i \leq \mathrm{omp\_get\_num\_threads()} \iff \\
    l &= max_i i \leq log_2 \mathrm{omp\_get\_num\_threads()} \iff \\
    l &= \lfloor log_2 \mathrm{omp\_get\_num\_threads()} \rfloor .\\
\end{split}
\end{equation}

Интуиција иза овога јесте да \textbf{паралелно} можемо да обрађујемо само онолико стабала колико имамо процесорских јединица на располагању.
Стога, треба да паралелно обрађујемо стабла са коренима на нивоу ком је број чворова такав да већ следећи ниво стабла има више чворова него
што програм има процесорске моћи.

\subsection{Аспекти OpenMP библиотекe}
\label{popravljena}

За имплементацију паралелног решења, коришћена је OpenMP библиотека.
Главна директива OpenMP библиотеке која је коришћена јесте задатак (енг. \textit{Task}).
Задатак је блок кода које извршно окружење OpenMP-а распоређује и извршава.

Дужност програмера је да назначи који блок кода представља задатак директивом \cinline{#pragma omp task}.
Када извршавање изворног кода "дође" до ове директиве, извршавање наредног блока преузима OpenMP,
гарантујући да ће се он извршити до следеће имплицитне или експлицитне директиве за завршетак извршавања задатака.
Ова директива може да се експлицитно наведе као: \cinline{#pragma omp taskwait}.

Начелно, не постоји ограничење на број задатака који могу да се извршавају конкурентно у OpenMP извршном окружењу.
Међутим, паралелно може да се извршава онолико задатака колико постоји процесуирајућих јединица на рачунару на ком
се програм извршава.

У самој имплементацији паралелног решења, како би се паралелно обрађивала стабла на нивоу $l$, \textbf{морамо да
креирамо задатке и за обраду чворова на нивоима мањим од $l$}.
То је једини начин да се независно креирају задаци за све чворове нивоа $l$. У супротном случају,
обрада би текла тако да се независно обради први пар чворова нивоа $l$, потом други итд.
То значи да је укупан број задатака за обраду једнак $2^{l+1} - 1$, односно, у случају да рачунар на ком се покреће решење има
4 процесуирајуће јединице, креираће се 7 задатка, на рачунару са 8 ПЈ креираће се 15 задатака итд.

\subsection{Паралелно решење}

У листингу \ref{code:paralelno} представљено је паралелно решење. 

\inputc{kodovi/parallel.c}{Имплементација паралелног решења у језику \texttt{C}}{code:paralelno}

Асимптотска сложеност овог решења је приближно:
$$O(n/p),$$
где је $n$ величина улаза тј. број чворова у графу, а $p$ број јединица паралелног извршавања.

\pagebreak